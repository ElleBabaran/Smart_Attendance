import tkinter as tk
from tkinter import font, messagebox
import cv2
from PIL import Image, ImageTk
from roboflow import Roboflow
import sqlite3
from datetime import datetime
import threading
import time
import queue
import os
from deepface import DeepFace

class AttendanceSystem:
    def __init__(self, root):
        self.root = root
        self.root.title("Smart Attendance System")
        self.root.geometry("600x500")
        
        # Colors
        self.bg_primary = "#1a1a2e"
        self.bg_secondary = "#16213e"
        self.accent_color = "#0f3460"
        self.highlight = "#e94560"
        self.success = "#06ffa5"
        self.warning = "#ffd700"
        self.text_light = "#eaeaea"
        self.root.configure(bg=self.bg_primary)

        # Camera & model
        self.cap = None
        self.camera_active = False
        self.model = None

        # Uniform detection
        self.female_items = ['brown dress', 'socks', 'black shoes', 'belt', 'id', 'ribbon']
        self.male_items = ['white polo', 'id', 'socks', 'black shoes', 'brown pants']
        self.current_gender = None
        self.last_predictions = []
        self.last_save_time = 0

        # Thread queues
        self.frame_queue = queue.Queue(maxsize=1)
        self.result_queue = queue.Queue(maxsize=1)
        self.detection_running = False

        # Bounding box colors
        self.CLASS_COLORS = {
            "white polo": (0, 255, 0),
            "brown pants": (0, 0, 255),
            "brown dress": (255, 0, 0),
            "ribbon": (255, 165, 0),
            "socks": (255, 255, 0),
            "black shoes": (128, 0, 128),
            "id": (0, 255, 255),
            "belt": (255, 20, 147),
        }

        # Directory for student images
        self.students_dir = "students"  # Each student has a folder with their name

        # Initialize database
        self.init_database()

        # Initialize Roboflow
        API_KEY = "YOUR_ROBOFLOW_API_KEY"
        WORKSPACE_NAME = "YOUR_WORKSPACE_NAME"
        PROJECT_NAME = "YOUR_PROJECT_NAME"
        VERSION = 5
        try:
            rf = Roboflow(api_key=API_KEY)
            workspace = rf.workspace(WORKSPACE_NAME)
            project = workspace.project(PROJECT_NAME)
            self.model = project.version(VERSION).model
            print("‚úì Model loaded!")
        except Exception as e:
            print(f"‚úó Model error: {e}")
            self.model = None

        self.show_main_menu()

    # --- Database ---
    def init_database(self):
        self.conn = sqlite3.connect('attendance.db', check_same_thread=False)
        self.cursor = self.conn.cursor()
        self.cursor.execute("DROP TABLE IF EXISTS attendance")
        self.cursor.execute('''
            CREATE TABLE attendance (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                student_name TEXT,
                uniform_status TEXT,
                missing_items TEXT,
                time TEXT,
                status TEXT,
                date TEXT
            )
        ''')
        self.conn.commit()

    def save_to_database(self, student_name, uniform_status, missing_items):
        def save_thread():
            current_time = datetime.now()
            date_str = current_time.strftime("%Y-%m-%d")
            time_str = current_time.strftime("%I:%M %p")
            cutoff_time = current_time.replace(hour=7, minute=1, second=0, microsecond=0)
            status = "Late" if current_time > cutoff_time else "On Time"
            missing_str = ", ".join(missing_items) if missing_items else "None"
            try:
                self.cursor.execute('''
                    INSERT INTO attendance (student_name, uniform_status, missing_items, time, status, date)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (student_name, uniform_status, missing_str, time_str, status, date_str))
                self.conn.commit()
                print(f"‚úì SAVED: {student_name} - {uniform_status} - Missing: {missing_str}")
            except Exception as e:
                print(f"Database save error: {e}")
        threading.Thread(target=save_thread, daemon=True).start()

    # --- GUI ---
    def show_main_menu(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        
        main_frame = tk.Frame(self.root, bg=self.bg_primary)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=40, pady=40)

        tk.Label(main_frame, text="üë§", font=("Arial", 40),
                 bg=self.bg_secondary, fg=self.success).pack(pady=(0, 20))
        tk.Label(main_frame, text="Smart Attendance",
                 font=("Segoe UI", 36, "bold"),
                 bg=self.bg_primary, fg=self.text_light).pack(pady=(0, 5))
        tk.Label(main_frame, text="Uniform & Face Detection System",
                 font=("Segoe UI", 14),
                 bg=self.bg_primary, fg="#888888").pack(pady=(0, 50))

        button_font = ("Segoe UI", 14, "bold")
        tk.Button(main_frame, text="START DETECTION", font=button_font,
                  bg=self.success, fg=self.bg_primary, width=25, height=2,
                  cursor="hand2", border=0, relief=tk.FLAT,
                  command=self.start_camera).pack(pady=12)

        tk.Button(main_frame, text="ADMIN PANEL", font=button_font,
                  bg=self.accent_color, fg=self.text_light, width=25, height=2,
                  cursor="hand2", border=0, relief=tk.FLAT,
                  command=self.open_admin).pack(pady=12)

        tk.Label(main_frame, text="Powered by Roboflow & DeepFace ‚Ä¢ v1.0",
                 font=("Segoe UI", 9),
                 bg=self.bg_primary, fg="#666666").pack(side=tk.BOTTOM, pady=20)

    # --- Camera & Detection ---
    def start_camera(self):
        if self.model is None:
            messagebox.showerror("Error", "Roboflow model not loaded!")
            return
        self.open_camera_window()
        def init_camera():
            try:
                self.cap = cv2.VideoCapture(0)
                self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
                self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
                self.cap.set(cv2.CAP_PROP_FPS, 30)
                time.sleep(0.5)
                self.camera_active = True
                self.detection_running = True
                self.last_predictions = []
                self.last_save_time = 0
                while not self.frame_queue.empty():
                    try: self.frame_queue.get_nowait()
                    except: break
                while not self.result_queue.empty():
                    try: self.result_queue.get_nowait()
                    except: break
                threading.Thread(target=self.detection_worker, daemon=True).start()
                self.root.after(10, self.update_camera)
            except Exception as e:
                print(f"Camera error: {e}")
                self.root.after(100, lambda: messagebox.showerror("Error", "Failed to open camera!"))
        threading.Thread(target=init_camera, daemon=True).start()

    def detection_worker(self):
        while self.detection_running:
            try:
                try:
                    frame = self.frame_queue.get(timeout=0.5)
                except queue.Empty:
                    continue
                temp_file = "temp_frame.jpg"
                cv2.imwrite(temp_file, frame, [cv2.IMWRITE_JPEG_QUALITY, 80])
                result = self.model.predict(temp_file, confidence=50, overlap=30)
                predictions = result.json()
                try: os.remove(temp_file)
                except: pass
                if 'predictions' in predictions and predictions['predictions']:
                    try:
                        if self.result_queue.empty():
                            self.result_queue.put_nowait(predictions['predictions'])
                    except queue.Full: pass
                else:
                    try:
                        if self.result_queue.empty():
                            self.result_queue.put_nowait([])
                    except queue.Full: pass
            except Exception as e:
                print(f"Detection error: {e}")
                time.sleep(0.5)

    def open_camera_window(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        self.root.geometry("1100x750")

        header_frame = tk.Frame(self.root, bg=self.bg_secondary, height=80)
        header_frame.pack(fill=tk.X)
        header_frame.pack_propagate(False)
        tk.Label(header_frame, text="üé•  Live Detection",
                 font=("Segoe UI", 22, "bold"),
                 bg=self.bg_secondary, fg=self.text_light).pack(pady=20)

        status_card = tk.Frame(self.root, bg=self.bg_secondary, height=100)
        status_card.pack(fill=tk.X, padx=30, pady=15)
        status_card.pack_propagate(False)
        self.status_label = tk.Label(status_card, text="Initializing camera...",
                                     font=("Segoe UI", 16, "bold"),
                                     bg=self.bg_secondary, fg=self.warning)
        self.status_label.pack(pady=10)
        self.missing_label = tk.Label(status_card, text="Please wait...",
                                      font=("Segoe UI", 11),
                                      bg=self.bg_secondary, fg="#ff6b6b", wraplength=1000)
        self.missing_label.pack(pady=5)

        camera_frame = tk.Frame(self.root, bg=self.bg_primary)
        camera_frame.pack(pady=10, padx=30, fill=tk.BOTH, expand=True)
        self.camera_label = tk.Label(camera_frame, bg=self.bg_primary,
                                     text="Starting camera...", font=("Segoe UI", 14),
                                     fg=self.text_light)
        self.camera_label.pack(fill=tk.BOTH, expand=True)

        back_button = tk.Button(camera_frame, text="‚Üê BACK TO MENU",
                                font=("Segoe UI", 11, "bold"),
                                bg=self.highlight, fg=self.text_light, width=18, height=2,
                                cursor="hand2", border=0, relief=tk.FLAT,
                                command=self.stop_camera)
        back_button.place(relx=1.0, rely=1.0, anchor=tk.SE, x=-20, y=-20)

    # --- Uniform check ---
    def check_uniform_completeness(self, predictions):
        detected_items = set(p['class'].lower().strip() for p in predictions)
        if 'brown dress' in detected_items or 'ribbon' in detected_items:
            self.current_gender = "Female"
            required_items = self.female_items
        elif 'white polo' in detected_items or 'brown pants' in detected_items:
            self.current_gender = "Male"
            required_items = self.male_items
        else:
            female_missing = sum(1 for item in self.female_items if item.lower() not in detected_items)
            male_missing = sum(1 for item in self.male_items if item.lower() not in detected_items)
            self.current_gender = "Female" if female_missing <= male_missing else "Male"
            required_items = self.female_items if self.current_gender == "Female" else self.male_items
        missing_items = [item for item in required_items if item.lower() not in detected_items]
        return len(missing_items) == 0, missing_items, detected_items

    # --- Face recognition ---
    def recognize_student(self, face_crop):
        for student_name in os.listdir(self.students_dir):
            student_folder = os.path.join(self.students_dir, student_name)
            if not os.path.isdir(student_folder):
                continue
            for img_file in os.listdir(student_folder):
                img_path = os.path.join(student_folder, img_file)
                try:
                    result = DeepFace.verify(face_crop, img_path, enforce_detection=False)
                    if result['verified']:
                        return student_name
                except:
                    continue
        return "Unknown"

    # --- Update loop ---
    def update_camera(self):
        if not self.camera_active or not self.cap or not self.cap.isOpened():
            return
        ret, frame = self.cap.read()
        if not ret:
            self.root.after(30, self.update_camera)
            return
        display_frame = frame.copy()
        current_time = time.time()
        try:
            if self.frame_queue.empty():
                self.frame_queue.put_nowait(frame.copy())
        except queue.Full:
            pass
        try:
            new_predictions = self.result_queue.get_nowait()
            self.last_predictions = new_predictions
        except queue.Empty:
            pass

        student_name = "Unknown"

        # --- Uniform boxes ---
        if self.last_predictions:
            is_complete, missing, detected = self.check_uniform_completeness(self.last_predictions)
            for pred in self.last_predictions:
                w, h = int(pred['width']), int(pred['height'])
                if w < 20 or h < 20:
                    continue
                x = int(pred['x'] - w / 2)
                y = int(pred['y'] - h / 2)
                color = self.CLASS_COLORS.get(pred['class'].lower(), (255, 255, 255))
                cv2.rectangle(display_frame, (x, y), (x + w, y + h), color, 3)
                label = f"{pred['class']} {pred['confidence']:.0%}"
                cv2.rectangle(display_frame, (x, y-25), (x + len(label)*12, y), color, -1)
                cv2.putText(display_frame, label, (x+5, y-8),
                            cv2.FONT_HERSHEY_DUPLEX, 0.6, (26, 26, 46), 2)
            gender_text = f"({self.current_gender})" if self.current_gender else ""
            if is_complete:
                self.status_label.config(text=f"‚úì COMPLETE UNIFORM {gender_text}", fg=self.success)
                self.missing_label.config(text="All required items present ‚úì")
            else:
                self.status_label.config(text=f"‚ö† INCOMPLETE UNIFORM {gender_text}", fg=self.highlight)
                self.missing_label.config(text=f"Missing: {', '.join(missing)}")
        else:
            self.status_label.config(text="üëÅ Scanning for uniform...", fg=self.warning)
            self.missing_label.config(text="Position yourself in front of the camera")

        # --- Face recognition ---
        try:
            # Detect faces
            import numpy as np
            faces = DeepFace.extract_faces(frame, detector_backend='retinaface', enforce_detection=False)
            for face in faces:
                x, y, w, h = face['facial_area']['x'], face['facial_area']['y'], \
                             face['facial_area']['w'], face['facial_area']['h']
                face_crop = frame[y:y+h, x:x+w]
                student_name = self.recognize_student(face_crop)
                cv2.rectangle(display_frame, (x, y), (x+w, y+h), (0,255,255), 2)
                cv2.putText(display_frame, student_name, (x, y-10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,255), 2)
        except Exception as e:
            print(f"Face detection error: {e}")

        # --- Save to database ---
        if current_time - self.last_save_time >= 5.0:
            self.last_save_time = current_time
            self.save_to_database(student_name, 
                                  "Complete" if self.last_predictions and is_complete else "Incomplete", 
                                  missing if self.last_predictions else [])

        # --- Display frame ---
        try:
            frame_rgb = cv2.cvtColor(display_frame, cv2.COLOR_BGR2RGB)
            frame_rgb = cv2.resize(frame_rgb, (800, 600))
            img = ImageTk.PhotoImage(image=Image.fromarray(frame_rgb))
            self.camera_label.config(image=img, text="")
            self.camera_label.image = img
        except Exception as e:
            print(f"Display error: {e}")

        self.root.after(16, self.update_camera)

    # --- Stop camera ---
    def stop_camera(self):
        self.camera_active = False
        self.detection_running = False
        time.sleep(0.3)
        if self.cap:
            self.cap.release()
            self.cap = None
        self.show_main_menu()

    # --- Admin panel placeholder ---
    def open_admin(self):
        messagebox.showinfo("Admin", "Admin panel not implemented yet.")

    # --- Exit cleanup ---
    def on_closing(self):
        self.camera_active = False
        self.detection_running = False
        if self.cap:
            self.cap.release()
        self.conn.close()
        self.root.destroy()


# --- Run App ---
if __name__ == "__main__":
    root = tk.Tk()
    app = AttendanceSystem(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    root.mainloop()

